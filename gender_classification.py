# -*- coding: utf-8 -*-
"""Gender Classification

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pDVypZgWaCtSPTzMIzZutVzbHjVtTIZh

Gender Classification
 by
 Raheel Riaz Rathore

## Libraries Imported
"""

#Logistic Regression
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.naive_bayes import BernoulliNB
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import LinearSVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
from sklearn import metrics
from sklearn.metrics import classification_report , accuracy_score , confusion_matrix
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')
from sklearn.metrics import confusion_matrix,classification_report
#linear Regression
import pandas as pd
import numpy as np
from sklearn.metrics import mean_absolute_error
from sklearn.model_selection import train_test_split
from sklearn.ensemble import GradientBoostingRegressor, RandomForestRegressor
from sklearn.svm import LinearSVR
from sklearn.metrics import r2_score
from sklearn.metrics import mean_absolute_error
from sklearn.linear_model import LinearRegression

"""## Importing Dataset"""

df = pd.read_csv("/content/drive/MyDrive/gender identification101.csv")
df

"""## Analysing Dataset"""

df.sort_values (by="long_hair")

df.sort_values (by="forehead_width_cm")

df.sort_values (by="nose_wide")

df.sort_values (by="nose_long")

df.sort_values (by="lips_thin")

df.sort_values (by="distance_nose_to_lip_long")

df.sort_values (by="long_hair",ascending=False)
df

df.info()

df.head()

df.tail()

df.columns

df.values

#Removing empty rows
df=pd.read_csv('/content/drive/MyDrive/gender identification101.csv')
newdf=df.dropna()
newdf

#To check duplicate values
df=pd.read_csv('/content/drive/MyDrive/gender identification101.csv')
print(df.duplicated())

#Removing Duplicate values
df=pd.read_csv('/content/drive/MyDrive/gender identification101.csv')
df=df.drop_duplicates()
df

df.describe()

df.dropna(inplace=True)
df

"""### Encoding Gender"""

df['gender'].replace(to_replace='Male', value=1, inplace=True)
df['gender'].replace(to_replace='Female', value=0, inplace=True)

label_encoder=LabelEncoder()
df["encoded_gender"]=label_encoder.fit_transform(df["gender"])
df

label_encoder=LabelEncoder()
df["encoded_gender"]=label_encoder.fit_transform(df["gender"])
df

#Label encoding
label_encoder=LabelEncoder()
df["encoded_long_hair"]=label_encoder.fit_transform(df["long_hair"])
df["encoded_forehead_width_cm"]=label_encoder.fit_transform(df["forehead_width_cm"])
df["encoded_forehead_height_cm"]=label_encoder.fit_transform(df["forehead_height_cm"])
df["encoded_nose_wide"]=label_encoder.fit_transform(df["nose_wide"])
df["encoded_nose_long"]=label_encoder.fit_transform(df["nose_long"])
df["encoded_lips_thin"]=label_encoder.fit_transform(df["lips_thin"])
df["encoded_distance_nose_to_lip_long"]=label_encoder.fit_transform(df["distance_nose_to_lip_long"])
df

df[df.forehead_width_cm>10]

df[df.forehead_width_cm>4]

"""### Data Vizualization"""

#Data Visualization
sns.pairplot(df , hue = 'gender')

sns.heatmap(df.corr(), cmap= 'coolwarm'  , annot=True)

sns.scatterplot (x='forehead_width_cm' , y = 'forehead_height_cm' , hue = 'gender',  data=df)

df.gender.value_counts().plot(kind = 'bar' , figsize = (6,6))

sns.countplot(x ='gender' , data = df)

sns.kdeplot(x='encoded_gender' , data = df , color = 'red')

"""## Application Of Classifiers"""

X=df[["long_hair","forehead_width_cm","forehead_height_cm","nose_wide","lips_thin","distance_nose_to_lip_long"]]
Y=df["gender"]

#train test split. 70/30
X_train,X_test,Y_train,Y_test=train_test_split(X,Y,test_size=0.3)

print(X_train.shape)
print(X_test.shape)
print(Y_train.shape)
print(Y_test.shape)

"""## Logistic Regression"""

model = LogisticRegression()
model.fit(X_train,Y_train)

Y_pred= model.predict(X_test)
print("Accuracy of Logistic Regression=")
# x_test is training data's input and y_test is testing data's input
acc=model.score(X_test,Y_test)
acc=round(acc,2)
print(acc)

model.coef_

model.intercept_

# Logistic Regression Report
print(classification_report(Y_test,Y_pred))

print(confusion_matrix( Y_test , Y_pred))

metrics.plot_roc_curve(model ,X_test , Y_test)

"""## KNeigbours"""

Knn_model = KNeighborsClassifier(n_neighbors=9)
Knn_model.fit(X_train , Y_train)
Y_pred_knn = Knn_model.predict(X_test)

#Knn report
print(classification_report(Y_test , Y_pred_knn))

print(confusion_matrix( Y_test , Y_pred_knn))

"""## LinearSVC"""

SVM=LinearSVC()
SVM.fit(X_train, Y_train)

Y_predicted_SVM = SVM.predict(X_test)

print(classification_report(Y_test , Y_predicted_SVM))

print(confusion_matrix( Y_test , Y_predicted_SVM))

"""## RandomForest"""

rf_model = RandomForestClassifier()
rf_model.fit(X_train , Y_train)

Y_prediction_rf= rf_model.predict(X_test)

# Report Random Forest Classifier
print(classification_report( Y_test , Y_prediction_rf))

print(confusion_matrix( Y_test , Y_prediction_rf))

"""## Naive Bayes"""

Nb = BernoulliNB()
Nb.fit(X_train, Y_train)

Y_predicted_nb = Nb.predict(X_test)

# Report of Naive Bayes
print(classification_report( Y_test , Y_predicted_nb))

print(confusion_matrix( Y_test , Y_predicted_nb))

"""# **Regression:**

## Importing Dataset
"""

lndf=pd.read_csv("/content/drive/MyDrive/LRHOUSE.csv")
lndf

"""## Analysing Dataset"""

lndf= lndf.drop(labels="date", axis=1)

lndf

lndf.head(5)

lndf.tail(5)

lndf.describe()

lndf.info()

lndf.columns

lndf.values

newlndf=lndf.dropna()
newlndf

print(lndf.duplicated())

lndf=lndf.drop_duplicates()
lndf

lndf[['floors', 'bathrooms', 'bedrooms','price']] = lndf[['floors', 'bathrooms', 'bedrooms','price']].astype('int')
lndf.dtypes

y = lndf.price
x = lndf.drop(['price'], axis=1)

x.head()

"""## Encoding Columns"""

en_street = LabelEncoder()
en_city = LabelEncoder()
en_statezip = LabelEncoder()
en_country = LabelEncoder()
x['street_encoded'] = en_street.fit_transform(x['street'])
x['city_encoded'] = en_city.fit_transform(x['city'])
x['statezip_encoded'] = en_statezip.fit_transform(x['statezip'])
x['country_encoded'] = en_country.fit_transform(x['country'])
x.head()

x=x.drop(['street','city','country','statezip'], axis =1)
x

x

y

"""## DataSplit: 70/30,Train=70,Test=30"""

x_train,x_test,y_train,y_test= train_test_split(x,y, test_size=0.3, random_state=42)

print(x_train.shape)
print(y_train.shape)
print(x_test.shape)
print(y_test.shape)

"""## Data Vizualization"""

fig = plt.subplots(figsize = (10,10))
sns.set(font_scale=1)
sns.heatmap(lndf.corr(),square = True,cbar=True,annot=True,annot_kws={'size': 10})
plt.show()

plt.figure(figsize=(5,5))
plt.scatter(y_test,ln_pred)
plt.xlabel("actual")
plt.ylabel("predicted")
plt.title("Actual vs  Predicted")
plt.show()

"""## Linear Regression"""

linearreg = LinearRegression()
linearreg.fit(x_train,y_train)
ln_pred = linearreg.predict(x_test)

print(linearreg.score(x_train, y_train))
print(linearreg.score(x_test,y_test))

print("Accuracy of linear Regression=")
linearreg.score(x_test,y_test)

print("Coefficient")
linearreg.coef_

print("Y-intercept")
linearreg.intercept_

print("MAE")
Error=round(mean_absolute_error(y_test, ln_pred),2)
Error

print("R2")
r2_score(y_test,ln_pred)

"""## Random Forest Regressor"""

RF=RandomForestRegressor()
RF.fit(x_train, y_train)
rfl_pred=RF.predict(x_test)

print(RF.score(x_train, y_train))
print(RF.score(x_test,y_test))

print("RF-error")
error=round(mean_absolute_error(y_test,rfl_pred),2)
Error

print("RF_R2")
r2_score(y_test,rfl_pred)

"""## Gradient_Booster_Regressor"""

GBRLN=GradientBoostingRegressor()
GBRLN.fit(x_train, y_train)
grln_pred=GBRLN.predict(x_test)

print(GBRLN.score(x_train, y_train))
print(GBRLN.score(x_test,y_test))

print("GB_MAE")
error=round(mean_absolute_error(y_test,grln_pred),2)
error

print("R2_gbrln")
r2_score(y_test,grln_pred)

"""## Linear_SVR"""

Linear_SVR=LinearSVR()
Linear_SVR.fit(x_train, y_train)
pred_SVR=Linear_SVR.predict(x_test)

print(Linear_SVR.score(x_train, y_train))
print(Linear_SVR.score(x_test,y_test))

score_SVR=round(mean_absolute_error(y_test, pred_SVR),2)
print("score=",score_SVR)

R2Score=r2_score(y_test,pred_SVR)
print("R2score",R2Score)